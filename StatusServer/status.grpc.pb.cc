// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: status.proto

#include "status.pb.h"
#include "status.grpc.pb.h"

#include <functional>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/channel_interface.h>
#include <grpcpp/impl/client_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/rpc_service_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/sync_stream.h>
namespace status {

static const char* StatusService_method_names[] = {
  "/status.StatusService/RegisterNode",
  "/status.StatusService/DeregisterNode",
  "/status.StatusService/Heartbeat",
  "/status.StatusService/AllocateServer",
  "/status.StatusService/ReportOnline",
  "/status.StatusService/ReportOffline",
  "/status.StatusService/QueryUserRoute",
  "/status.StatusService/KickUser",
  "/status.StatusService/GetNodes",
};

std::unique_ptr< StatusService::Stub> StatusService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< StatusService::Stub> stub(new StatusService::Stub(channel, options));
  return stub;
}

StatusService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_RegisterNode_(StatusService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_DeregisterNode_(StatusService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Heartbeat_(StatusService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_AllocateServer_(StatusService_method_names[3], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ReportOnline_(StatusService_method_names[4], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ReportOffline_(StatusService_method_names[5], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_QueryUserRoute_(StatusService_method_names[6], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_KickUser_(StatusService_method_names[7], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetNodes_(StatusService_method_names[8], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status StatusService::Stub::RegisterNode(::grpc::ClientContext* context, const ::status::RegisterNodeReq& request, ::status::RegisterNodeResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::status::RegisterNodeReq, ::status::RegisterNodeResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_RegisterNode_, context, request, response);
}

void StatusService::Stub::async::RegisterNode(::grpc::ClientContext* context, const ::status::RegisterNodeReq* request, ::status::RegisterNodeResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::status::RegisterNodeReq, ::status::RegisterNodeResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_RegisterNode_, context, request, response, std::move(f));
}

void StatusService::Stub::async::RegisterNode(::grpc::ClientContext* context, const ::status::RegisterNodeReq* request, ::status::RegisterNodeResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_RegisterNode_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::status::RegisterNodeResp>* StatusService::Stub::PrepareAsyncRegisterNodeRaw(::grpc::ClientContext* context, const ::status::RegisterNodeReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::status::RegisterNodeResp, ::status::RegisterNodeReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_RegisterNode_, context, request);
}

::grpc::ClientAsyncResponseReader< ::status::RegisterNodeResp>* StatusService::Stub::AsyncRegisterNodeRaw(::grpc::ClientContext* context, const ::status::RegisterNodeReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncRegisterNodeRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status StatusService::Stub::DeregisterNode(::grpc::ClientContext* context, const ::status::DeregisterNodeReq& request, ::status::DeregisterNodeResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::status::DeregisterNodeReq, ::status::DeregisterNodeResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_DeregisterNode_, context, request, response);
}

void StatusService::Stub::async::DeregisterNode(::grpc::ClientContext* context, const ::status::DeregisterNodeReq* request, ::status::DeregisterNodeResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::status::DeregisterNodeReq, ::status::DeregisterNodeResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_DeregisterNode_, context, request, response, std::move(f));
}

void StatusService::Stub::async::DeregisterNode(::grpc::ClientContext* context, const ::status::DeregisterNodeReq* request, ::status::DeregisterNodeResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_DeregisterNode_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::status::DeregisterNodeResp>* StatusService::Stub::PrepareAsyncDeregisterNodeRaw(::grpc::ClientContext* context, const ::status::DeregisterNodeReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::status::DeregisterNodeResp, ::status::DeregisterNodeReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_DeregisterNode_, context, request);
}

::grpc::ClientAsyncResponseReader< ::status::DeregisterNodeResp>* StatusService::Stub::AsyncDeregisterNodeRaw(::grpc::ClientContext* context, const ::status::DeregisterNodeReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncDeregisterNodeRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status StatusService::Stub::Heartbeat(::grpc::ClientContext* context, const ::status::HeartbeatReq& request, ::status::HeartbeatResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::status::HeartbeatReq, ::status::HeartbeatResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Heartbeat_, context, request, response);
}

void StatusService::Stub::async::Heartbeat(::grpc::ClientContext* context, const ::status::HeartbeatReq* request, ::status::HeartbeatResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::status::HeartbeatReq, ::status::HeartbeatResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Heartbeat_, context, request, response, std::move(f));
}

void StatusService::Stub::async::Heartbeat(::grpc::ClientContext* context, const ::status::HeartbeatReq* request, ::status::HeartbeatResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Heartbeat_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::status::HeartbeatResp>* StatusService::Stub::PrepareAsyncHeartbeatRaw(::grpc::ClientContext* context, const ::status::HeartbeatReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::status::HeartbeatResp, ::status::HeartbeatReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Heartbeat_, context, request);
}

::grpc::ClientAsyncResponseReader< ::status::HeartbeatResp>* StatusService::Stub::AsyncHeartbeatRaw(::grpc::ClientContext* context, const ::status::HeartbeatReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncHeartbeatRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status StatusService::Stub::AllocateServer(::grpc::ClientContext* context, const ::status::AllocateServerReq& request, ::status::AllocateServerResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::status::AllocateServerReq, ::status::AllocateServerResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_AllocateServer_, context, request, response);
}

void StatusService::Stub::async::AllocateServer(::grpc::ClientContext* context, const ::status::AllocateServerReq* request, ::status::AllocateServerResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::status::AllocateServerReq, ::status::AllocateServerResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AllocateServer_, context, request, response, std::move(f));
}

void StatusService::Stub::async::AllocateServer(::grpc::ClientContext* context, const ::status::AllocateServerReq* request, ::status::AllocateServerResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AllocateServer_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::status::AllocateServerResp>* StatusService::Stub::PrepareAsyncAllocateServerRaw(::grpc::ClientContext* context, const ::status::AllocateServerReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::status::AllocateServerResp, ::status::AllocateServerReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_AllocateServer_, context, request);
}

::grpc::ClientAsyncResponseReader< ::status::AllocateServerResp>* StatusService::Stub::AsyncAllocateServerRaw(::grpc::ClientContext* context, const ::status::AllocateServerReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncAllocateServerRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status StatusService::Stub::ReportOnline(::grpc::ClientContext* context, const ::status::OnlineReportReq& request, ::status::OnlineReportResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::status::OnlineReportReq, ::status::OnlineReportResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ReportOnline_, context, request, response);
}

void StatusService::Stub::async::ReportOnline(::grpc::ClientContext* context, const ::status::OnlineReportReq* request, ::status::OnlineReportResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::status::OnlineReportReq, ::status::OnlineReportResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ReportOnline_, context, request, response, std::move(f));
}

void StatusService::Stub::async::ReportOnline(::grpc::ClientContext* context, const ::status::OnlineReportReq* request, ::status::OnlineReportResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ReportOnline_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::status::OnlineReportResp>* StatusService::Stub::PrepareAsyncReportOnlineRaw(::grpc::ClientContext* context, const ::status::OnlineReportReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::status::OnlineReportResp, ::status::OnlineReportReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ReportOnline_, context, request);
}

::grpc::ClientAsyncResponseReader< ::status::OnlineReportResp>* StatusService::Stub::AsyncReportOnlineRaw(::grpc::ClientContext* context, const ::status::OnlineReportReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncReportOnlineRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status StatusService::Stub::ReportOffline(::grpc::ClientContext* context, const ::status::OfflineReportReq& request, ::status::OfflineReportResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::status::OfflineReportReq, ::status::OfflineReportResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ReportOffline_, context, request, response);
}

void StatusService::Stub::async::ReportOffline(::grpc::ClientContext* context, const ::status::OfflineReportReq* request, ::status::OfflineReportResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::status::OfflineReportReq, ::status::OfflineReportResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ReportOffline_, context, request, response, std::move(f));
}

void StatusService::Stub::async::ReportOffline(::grpc::ClientContext* context, const ::status::OfflineReportReq* request, ::status::OfflineReportResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ReportOffline_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::status::OfflineReportResp>* StatusService::Stub::PrepareAsyncReportOfflineRaw(::grpc::ClientContext* context, const ::status::OfflineReportReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::status::OfflineReportResp, ::status::OfflineReportReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ReportOffline_, context, request);
}

::grpc::ClientAsyncResponseReader< ::status::OfflineReportResp>* StatusService::Stub::AsyncReportOfflineRaw(::grpc::ClientContext* context, const ::status::OfflineReportReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncReportOfflineRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status StatusService::Stub::QueryUserRoute(::grpc::ClientContext* context, const ::status::RouteReq& request, ::status::RouteResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::status::RouteReq, ::status::RouteResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_QueryUserRoute_, context, request, response);
}

void StatusService::Stub::async::QueryUserRoute(::grpc::ClientContext* context, const ::status::RouteReq* request, ::status::RouteResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::status::RouteReq, ::status::RouteResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_QueryUserRoute_, context, request, response, std::move(f));
}

void StatusService::Stub::async::QueryUserRoute(::grpc::ClientContext* context, const ::status::RouteReq* request, ::status::RouteResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_QueryUserRoute_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::status::RouteResp>* StatusService::Stub::PrepareAsyncQueryUserRouteRaw(::grpc::ClientContext* context, const ::status::RouteReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::status::RouteResp, ::status::RouteReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_QueryUserRoute_, context, request);
}

::grpc::ClientAsyncResponseReader< ::status::RouteResp>* StatusService::Stub::AsyncQueryUserRouteRaw(::grpc::ClientContext* context, const ::status::RouteReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncQueryUserRouteRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status StatusService::Stub::KickUser(::grpc::ClientContext* context, const ::status::KickUserReq& request, ::status::KickUserResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::status::KickUserReq, ::status::KickUserResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_KickUser_, context, request, response);
}

void StatusService::Stub::async::KickUser(::grpc::ClientContext* context, const ::status::KickUserReq* request, ::status::KickUserResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::status::KickUserReq, ::status::KickUserResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_KickUser_, context, request, response, std::move(f));
}

void StatusService::Stub::async::KickUser(::grpc::ClientContext* context, const ::status::KickUserReq* request, ::status::KickUserResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_KickUser_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::status::KickUserResp>* StatusService::Stub::PrepareAsyncKickUserRaw(::grpc::ClientContext* context, const ::status::KickUserReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::status::KickUserResp, ::status::KickUserReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_KickUser_, context, request);
}

::grpc::ClientAsyncResponseReader< ::status::KickUserResp>* StatusService::Stub::AsyncKickUserRaw(::grpc::ClientContext* context, const ::status::KickUserReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncKickUserRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status StatusService::Stub::GetNodes(::grpc::ClientContext* context, const ::status::GetNodesReq& request, ::status::GetNodesResp* response) {
  return ::grpc::internal::BlockingUnaryCall< ::status::GetNodesReq, ::status::GetNodesResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_GetNodes_, context, request, response);
}

void StatusService::Stub::async::GetNodes(::grpc::ClientContext* context, const ::status::GetNodesReq* request, ::status::GetNodesResp* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::status::GetNodesReq, ::status::GetNodesResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetNodes_, context, request, response, std::move(f));
}

void StatusService::Stub::async::GetNodes(::grpc::ClientContext* context, const ::status::GetNodesReq* request, ::status::GetNodesResp* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_GetNodes_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::status::GetNodesResp>* StatusService::Stub::PrepareAsyncGetNodesRaw(::grpc::ClientContext* context, const ::status::GetNodesReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::status::GetNodesResp, ::status::GetNodesReq, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_GetNodes_, context, request);
}

::grpc::ClientAsyncResponseReader< ::status::GetNodesResp>* StatusService::Stub::AsyncGetNodesRaw(::grpc::ClientContext* context, const ::status::GetNodesReq& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncGetNodesRaw(context, request, cq);
  result->StartCall();
  return result;
}

StatusService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      StatusService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< StatusService::Service, ::status::RegisterNodeReq, ::status::RegisterNodeResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](StatusService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::status::RegisterNodeReq* req,
             ::status::RegisterNodeResp* resp) {
               return service->RegisterNode(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      StatusService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< StatusService::Service, ::status::DeregisterNodeReq, ::status::DeregisterNodeResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](StatusService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::status::DeregisterNodeReq* req,
             ::status::DeregisterNodeResp* resp) {
               return service->DeregisterNode(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      StatusService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< StatusService::Service, ::status::HeartbeatReq, ::status::HeartbeatResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](StatusService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::status::HeartbeatReq* req,
             ::status::HeartbeatResp* resp) {
               return service->Heartbeat(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      StatusService_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< StatusService::Service, ::status::AllocateServerReq, ::status::AllocateServerResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](StatusService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::status::AllocateServerReq* req,
             ::status::AllocateServerResp* resp) {
               return service->AllocateServer(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      StatusService_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< StatusService::Service, ::status::OnlineReportReq, ::status::OnlineReportResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](StatusService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::status::OnlineReportReq* req,
             ::status::OnlineReportResp* resp) {
               return service->ReportOnline(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      StatusService_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< StatusService::Service, ::status::OfflineReportReq, ::status::OfflineReportResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](StatusService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::status::OfflineReportReq* req,
             ::status::OfflineReportResp* resp) {
               return service->ReportOffline(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      StatusService_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< StatusService::Service, ::status::RouteReq, ::status::RouteResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](StatusService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::status::RouteReq* req,
             ::status::RouteResp* resp) {
               return service->QueryUserRoute(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      StatusService_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< StatusService::Service, ::status::KickUserReq, ::status::KickUserResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](StatusService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::status::KickUserReq* req,
             ::status::KickUserResp* resp) {
               return service->KickUser(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      StatusService_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< StatusService::Service, ::status::GetNodesReq, ::status::GetNodesResp, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](StatusService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::status::GetNodesReq* req,
             ::status::GetNodesResp* resp) {
               return service->GetNodes(ctx, req, resp);
             }, this)));
}

StatusService::Service::~Service() {
}

::grpc::Status StatusService::Service::RegisterNode(::grpc::ServerContext* context, const ::status::RegisterNodeReq* request, ::status::RegisterNodeResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status StatusService::Service::DeregisterNode(::grpc::ServerContext* context, const ::status::DeregisterNodeReq* request, ::status::DeregisterNodeResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status StatusService::Service::Heartbeat(::grpc::ServerContext* context, const ::status::HeartbeatReq* request, ::status::HeartbeatResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status StatusService::Service::AllocateServer(::grpc::ServerContext* context, const ::status::AllocateServerReq* request, ::status::AllocateServerResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status StatusService::Service::ReportOnline(::grpc::ServerContext* context, const ::status::OnlineReportReq* request, ::status::OnlineReportResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status StatusService::Service::ReportOffline(::grpc::ServerContext* context, const ::status::OfflineReportReq* request, ::status::OfflineReportResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status StatusService::Service::QueryUserRoute(::grpc::ServerContext* context, const ::status::RouteReq* request, ::status::RouteResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status StatusService::Service::KickUser(::grpc::ServerContext* context, const ::status::KickUserReq* request, ::status::KickUserResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status StatusService::Service::GetNodes(::grpc::ServerContext* context, const ::status::GetNodesReq* request, ::status::GetNodesResp* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace status

