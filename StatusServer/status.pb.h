// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: status.proto
// Protobuf C++ Version: 5.29.3

#ifndef status_2eproto_2epb_2eh
#define status_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_status_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_status_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_status_2eproto;
namespace status {
class AllocateServerReq;
struct AllocateServerReqDefaultTypeInternal;
extern AllocateServerReqDefaultTypeInternal _AllocateServerReq_default_instance_;
class AllocateServerResp;
struct AllocateServerRespDefaultTypeInternal;
extern AllocateServerRespDefaultTypeInternal _AllocateServerResp_default_instance_;
class DeregisterNodeReq;
struct DeregisterNodeReqDefaultTypeInternal;
extern DeregisterNodeReqDefaultTypeInternal _DeregisterNodeReq_default_instance_;
class DeregisterNodeResp;
struct DeregisterNodeRespDefaultTypeInternal;
extern DeregisterNodeRespDefaultTypeInternal _DeregisterNodeResp_default_instance_;
class GetNodesReq;
struct GetNodesReqDefaultTypeInternal;
extern GetNodesReqDefaultTypeInternal _GetNodesReq_default_instance_;
class GetNodesResp;
struct GetNodesRespDefaultTypeInternal;
extern GetNodesRespDefaultTypeInternal _GetNodesResp_default_instance_;
class HeartbeatReq;
struct HeartbeatReqDefaultTypeInternal;
extern HeartbeatReqDefaultTypeInternal _HeartbeatReq_default_instance_;
class HeartbeatResp;
struct HeartbeatRespDefaultTypeInternal;
extern HeartbeatRespDefaultTypeInternal _HeartbeatResp_default_instance_;
class KickUserReq;
struct KickUserReqDefaultTypeInternal;
extern KickUserReqDefaultTypeInternal _KickUserReq_default_instance_;
class KickUserResp;
struct KickUserRespDefaultTypeInternal;
extern KickUserRespDefaultTypeInternal _KickUserResp_default_instance_;
class NodeInfo;
struct NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
class OfflineReportReq;
struct OfflineReportReqDefaultTypeInternal;
extern OfflineReportReqDefaultTypeInternal _OfflineReportReq_default_instance_;
class OfflineReportResp;
struct OfflineReportRespDefaultTypeInternal;
extern OfflineReportRespDefaultTypeInternal _OfflineReportResp_default_instance_;
class OnlineReportReq;
struct OnlineReportReqDefaultTypeInternal;
extern OnlineReportReqDefaultTypeInternal _OnlineReportReq_default_instance_;
class OnlineReportResp;
struct OnlineReportRespDefaultTypeInternal;
extern OnlineReportRespDefaultTypeInternal _OnlineReportResp_default_instance_;
class RegisterNodeReq;
struct RegisterNodeReqDefaultTypeInternal;
extern RegisterNodeReqDefaultTypeInternal _RegisterNodeReq_default_instance_;
class RegisterNodeResp;
struct RegisterNodeRespDefaultTypeInternal;
extern RegisterNodeRespDefaultTypeInternal _RegisterNodeResp_default_instance_;
class RouteReq;
struct RouteReqDefaultTypeInternal;
extern RouteReqDefaultTypeInternal _RouteReq_default_instance_;
class RouteResp;
struct RouteRespDefaultTypeInternal;
extern RouteRespDefaultTypeInternal _RouteResp_default_instance_;
}  // namespace status
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace status {

// ===================================================================


// -------------------------------------------------------------------

class RouteResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.RouteResp) */ {
 public:
  inline RouteResp() : RouteResp(nullptr) {}
  ~RouteResp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RouteResp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RouteResp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RouteResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline RouteResp(const RouteResp& from) : RouteResp(nullptr, from) {}
  inline RouteResp(RouteResp&& from) noexcept
      : RouteResp(nullptr, std::move(from)) {}
  inline RouteResp& operator=(const RouteResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteResp& operator=(RouteResp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteResp* internal_default_instance() {
    return reinterpret_cast<const RouteResp*>(
        &_RouteResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(RouteResp& a, RouteResp& b) { a.Swap(&b); }
  inline void Swap(RouteResp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteResp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RouteResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouteResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RouteResp& from) { RouteResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RouteResp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.RouteResp"; }

 protected:
  explicit RouteResp(::google::protobuf::Arena* arena);
  RouteResp(::google::protobuf::Arena* arena, const RouteResp& from);
  RouteResp(::google::protobuf::Arena* arena, RouteResp&& from) noexcept
      : RouteResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kServerNameFieldNumber = 3,
    kServerHostFieldNumber = 4,
    kTokenFieldNumber = 6,
    kErrorFieldNumber = 1,
    kOnlineFieldNumber = 2,
    kLastLogoutFieldNumber = 7,
    kServerPortFieldNumber = 5,
  };
  // string server_name = 3;
  void clear_server_name() ;
  const std::string& server_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_name(Arg_&& arg, Args_... args);
  std::string* mutable_server_name();
  PROTOBUF_NODISCARD std::string* release_server_name();
  void set_allocated_server_name(std::string* value);

  private:
  const std::string& _internal_server_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_name(
      const std::string& value);
  std::string* _internal_mutable_server_name();

  public:
  // string server_host = 4;
  void clear_server_host() ;
  const std::string& server_host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_host(Arg_&& arg, Args_... args);
  std::string* mutable_server_host();
  PROTOBUF_NODISCARD std::string* release_server_host();
  void set_allocated_server_host(std::string* value);

  private:
  const std::string& _internal_server_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_host(
      const std::string& value);
  std::string* _internal_mutable_server_host();

  public:
  // string token = 6;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // int32 error = 1;
  void clear_error() ;
  ::int32_t error() const;
  void set_error(::int32_t value);

  private:
  ::int32_t _internal_error() const;
  void _internal_set_error(::int32_t value);

  public:
  // bool online = 2;
  void clear_online() ;
  bool online() const;
  void set_online(bool value);

  private:
  bool _internal_online() const;
  void _internal_set_online(bool value);

  public:
  // int64 last_logout = 7;
  void clear_last_logout() ;
  ::int64_t last_logout() const;
  void set_last_logout(::int64_t value);

  private:
  ::int64_t _internal_last_logout() const;
  void _internal_set_last_logout(::int64_t value);

  public:
  // int32 server_port = 5;
  void clear_server_port() ;
  ::int32_t server_port() const;
  void set_server_port(::int32_t value);

  private:
  ::int32_t _internal_server_port() const;
  void _internal_set_server_port(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:status.RouteResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      52, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RouteResp& from_msg);
    ::google::protobuf::internal::ArenaStringPtr server_name_;
    ::google::protobuf::internal::ArenaStringPtr server_host_;
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::int32_t error_;
    bool online_;
    ::int64_t last_logout_;
    ::int32_t server_port_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class RouteReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.RouteReq) */ {
 public:
  inline RouteReq() : RouteReq(nullptr) {}
  ~RouteReq() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RouteReq* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RouteReq));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RouteReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline RouteReq(const RouteReq& from) : RouteReq(nullptr, from) {}
  inline RouteReq(RouteReq&& from) noexcept
      : RouteReq(nullptr, std::move(from)) {}
  inline RouteReq& operator=(const RouteReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteReq& operator=(RouteReq&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteReq* internal_default_instance() {
    return reinterpret_cast<const RouteReq*>(
        &_RouteReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(RouteReq& a, RouteReq& b) { a.Swap(&b); }
  inline void Swap(RouteReq* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteReq* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RouteReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RouteReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RouteReq& from) { RouteReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RouteReq* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.RouteReq"; }

 protected:
  explicit RouteReq(::google::protobuf::Arena* arena);
  RouteReq(::google::protobuf::Arena* arena, const RouteReq& from);
  RouteReq(::google::protobuf::Arena* arena, RouteReq&& from) noexcept
      : RouteReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUidFieldNumber = 1,
  };
  // string uid = 1;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // @@protoc_insertion_point(class_scope:status.RouteReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      27, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RouteReq& from_msg);
    ::google::protobuf::internal::ArenaStringPtr uid_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class RegisterNodeResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.RegisterNodeResp) */ {
 public:
  inline RegisterNodeResp() : RegisterNodeResp(nullptr) {}
  ~RegisterNodeResp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegisterNodeResp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegisterNodeResp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterNodeResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterNodeResp(const RegisterNodeResp& from) : RegisterNodeResp(nullptr, from) {}
  inline RegisterNodeResp(RegisterNodeResp&& from) noexcept
      : RegisterNodeResp(nullptr, std::move(from)) {}
  inline RegisterNodeResp& operator=(const RegisterNodeResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterNodeResp& operator=(RegisterNodeResp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterNodeResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterNodeResp* internal_default_instance() {
    return reinterpret_cast<const RegisterNodeResp*>(
        &_RegisterNodeResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(RegisterNodeResp& a, RegisterNodeResp& b) { a.Swap(&b); }
  inline void Swap(RegisterNodeResp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterNodeResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterNodeResp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegisterNodeResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterNodeResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterNodeResp& from) { RegisterNodeResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegisterNodeResp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.RegisterNodeResp"; }

 protected:
  explicit RegisterNodeResp(::google::protobuf::Arena* arena);
  RegisterNodeResp(::google::protobuf::Arena* arena, const RegisterNodeResp& from);
  RegisterNodeResp(::google::protobuf::Arena* arena, RegisterNodeResp&& from) noexcept
      : RegisterNodeResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 1,
  };
  // int32 error = 1;
  void clear_error() ;
  ::int32_t error() const;
  void set_error(::int32_t value);

  private:
  ::int32_t _internal_error() const;
  void _internal_set_error(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:status.RegisterNodeResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RegisterNodeResp& from_msg);
    ::int32_t error_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class RegisterNodeReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.RegisterNodeReq) */ {
 public:
  inline RegisterNodeReq() : RegisterNodeReq(nullptr) {}
  ~RegisterNodeReq() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RegisterNodeReq* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RegisterNodeReq));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RegisterNodeReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline RegisterNodeReq(const RegisterNodeReq& from) : RegisterNodeReq(nullptr, from) {}
  inline RegisterNodeReq(RegisterNodeReq&& from) noexcept
      : RegisterNodeReq(nullptr, std::move(from)) {}
  inline RegisterNodeReq& operator=(const RegisterNodeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterNodeReq& operator=(RegisterNodeReq&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterNodeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterNodeReq* internal_default_instance() {
    return reinterpret_cast<const RegisterNodeReq*>(
        &_RegisterNodeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(RegisterNodeReq& a, RegisterNodeReq& b) { a.Swap(&b); }
  inline void Swap(RegisterNodeReq* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterNodeReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterNodeReq* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RegisterNodeReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RegisterNodeReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RegisterNodeReq& from) { RegisterNodeReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RegisterNodeReq* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.RegisterNodeReq"; }

 protected:
  explicit RegisterNodeReq(::google::protobuf::Arena* arena);
  RegisterNodeReq(::google::protobuf::Arena* arena, const RegisterNodeReq& from);
  RegisterNodeReq(::google::protobuf::Arena* arena, RegisterNodeReq&& from) noexcept
      : RegisterNodeReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kServerHostFieldNumber = 2,
    kServerPortFieldNumber = 3,
    kCapacityFieldNumber = 4,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string server_host = 2;
  void clear_server_host() ;
  const std::string& server_host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_host(Arg_&& arg, Args_... args);
  std::string* mutable_server_host();
  PROTOBUF_NODISCARD std::string* release_server_host();
  void set_allocated_server_host(std::string* value);

  private:
  const std::string& _internal_server_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_host(
      const std::string& value);
  std::string* _internal_mutable_server_host();

  public:
  // int32 server_port = 3;
  void clear_server_port() ;
  ::int32_t server_port() const;
  void set_server_port(::int32_t value);

  private:
  ::int32_t _internal_server_port() const;
  void _internal_set_server_port(::int32_t value);

  public:
  // int32 capacity = 4;
  void clear_capacity() ;
  ::int32_t capacity() const;
  void set_capacity(::int32_t value);

  private:
  ::int32_t _internal_capacity() const;
  void _internal_set_capacity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:status.RegisterNodeReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      46, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RegisterNodeReq& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr server_host_;
    ::int32_t server_port_;
    ::int32_t capacity_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class OnlineReportResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.OnlineReportResp) */ {
 public:
  inline OnlineReportResp() : OnlineReportResp(nullptr) {}
  ~OnlineReportResp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OnlineReportResp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OnlineReportResp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OnlineReportResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline OnlineReportResp(const OnlineReportResp& from) : OnlineReportResp(nullptr, from) {}
  inline OnlineReportResp(OnlineReportResp&& from) noexcept
      : OnlineReportResp(nullptr, std::move(from)) {}
  inline OnlineReportResp& operator=(const OnlineReportResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnlineReportResp& operator=(OnlineReportResp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnlineReportResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnlineReportResp* internal_default_instance() {
    return reinterpret_cast<const OnlineReportResp*>(
        &_OnlineReportResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(OnlineReportResp& a, OnlineReportResp& b) { a.Swap(&b); }
  inline void Swap(OnlineReportResp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnlineReportResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnlineReportResp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OnlineReportResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OnlineReportResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OnlineReportResp& from) { OnlineReportResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OnlineReportResp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.OnlineReportResp"; }

 protected:
  explicit OnlineReportResp(::google::protobuf::Arena* arena);
  OnlineReportResp(::google::protobuf::Arena* arena, const OnlineReportResp& from);
  OnlineReportResp(::google::protobuf::Arena* arena, OnlineReportResp&& from) noexcept
      : OnlineReportResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 1,
  };
  // int32 error = 1;
  void clear_error() ;
  ::int32_t error() const;
  void set_error(::int32_t value);

  private:
  ::int32_t _internal_error() const;
  void _internal_set_error(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:status.OnlineReportResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OnlineReportResp& from_msg);
    ::int32_t error_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class OnlineReportReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.OnlineReportReq) */ {
 public:
  inline OnlineReportReq() : OnlineReportReq(nullptr) {}
  ~OnlineReportReq() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OnlineReportReq* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OnlineReportReq));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OnlineReportReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline OnlineReportReq(const OnlineReportReq& from) : OnlineReportReq(nullptr, from) {}
  inline OnlineReportReq(OnlineReportReq&& from) noexcept
      : OnlineReportReq(nullptr, std::move(from)) {}
  inline OnlineReportReq& operator=(const OnlineReportReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline OnlineReportReq& operator=(OnlineReportReq&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OnlineReportReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const OnlineReportReq* internal_default_instance() {
    return reinterpret_cast<const OnlineReportReq*>(
        &_OnlineReportReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(OnlineReportReq& a, OnlineReportReq& b) { a.Swap(&b); }
  inline void Swap(OnlineReportReq* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OnlineReportReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OnlineReportReq* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OnlineReportReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OnlineReportReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OnlineReportReq& from) { OnlineReportReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OnlineReportReq* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.OnlineReportReq"; }

 protected:
  explicit OnlineReportReq(::google::protobuf::Arena* arena);
  OnlineReportReq(::google::protobuf::Arena* arena, const OnlineReportReq& from);
  OnlineReportReq(::google::protobuf::Arena* arena, OnlineReportReq&& from) noexcept
      : OnlineReportReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUidFieldNumber = 1,
    kServerNameFieldNumber = 2,
    kServerHostFieldNumber = 3,
    kTokenFieldNumber = 5,
    kServerPortFieldNumber = 4,
  };
  // string uid = 1;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // string server_name = 2;
  void clear_server_name() ;
  const std::string& server_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_name(Arg_&& arg, Args_... args);
  std::string* mutable_server_name();
  PROTOBUF_NODISCARD std::string* release_server_name();
  void set_allocated_server_name(std::string* value);

  private:
  const std::string& _internal_server_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_name(
      const std::string& value);
  std::string* _internal_mutable_server_name();

  public:
  // string server_host = 3;
  void clear_server_host() ;
  const std::string& server_host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_host(Arg_&& arg, Args_... args);
  std::string* mutable_server_host();
  PROTOBUF_NODISCARD std::string* release_server_host();
  void set_allocated_server_host(std::string* value);

  private:
  const std::string& _internal_server_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_host(
      const std::string& value);
  std::string* _internal_mutable_server_host();

  public:
  // string token = 5;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // int32 server_port = 4;
  void clear_server_port() ;
  ::int32_t server_port() const;
  void set_server_port(::int32_t value);

  private:
  ::int32_t _internal_server_port() const;
  void _internal_set_server_port(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:status.OnlineReportReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      61, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OnlineReportReq& from_msg);
    ::google::protobuf::internal::ArenaStringPtr uid_;
    ::google::protobuf::internal::ArenaStringPtr server_name_;
    ::google::protobuf::internal::ArenaStringPtr server_host_;
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::int32_t server_port_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class OfflineReportResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.OfflineReportResp) */ {
 public:
  inline OfflineReportResp() : OfflineReportResp(nullptr) {}
  ~OfflineReportResp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OfflineReportResp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OfflineReportResp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OfflineReportResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline OfflineReportResp(const OfflineReportResp& from) : OfflineReportResp(nullptr, from) {}
  inline OfflineReportResp(OfflineReportResp&& from) noexcept
      : OfflineReportResp(nullptr, std::move(from)) {}
  inline OfflineReportResp& operator=(const OfflineReportResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline OfflineReportResp& operator=(OfflineReportResp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OfflineReportResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const OfflineReportResp* internal_default_instance() {
    return reinterpret_cast<const OfflineReportResp*>(
        &_OfflineReportResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(OfflineReportResp& a, OfflineReportResp& b) { a.Swap(&b); }
  inline void Swap(OfflineReportResp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OfflineReportResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OfflineReportResp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OfflineReportResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OfflineReportResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OfflineReportResp& from) { OfflineReportResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OfflineReportResp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.OfflineReportResp"; }

 protected:
  explicit OfflineReportResp(::google::protobuf::Arena* arena);
  OfflineReportResp(::google::protobuf::Arena* arena, const OfflineReportResp& from);
  OfflineReportResp(::google::protobuf::Arena* arena, OfflineReportResp&& from) noexcept
      : OfflineReportResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 1,
  };
  // int32 error = 1;
  void clear_error() ;
  ::int32_t error() const;
  void set_error(::int32_t value);

  private:
  ::int32_t _internal_error() const;
  void _internal_set_error(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:status.OfflineReportResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OfflineReportResp& from_msg);
    ::int32_t error_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class OfflineReportReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.OfflineReportReq) */ {
 public:
  inline OfflineReportReq() : OfflineReportReq(nullptr) {}
  ~OfflineReportReq() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(OfflineReportReq* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(OfflineReportReq));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR OfflineReportReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline OfflineReportReq(const OfflineReportReq& from) : OfflineReportReq(nullptr, from) {}
  inline OfflineReportReq(OfflineReportReq&& from) noexcept
      : OfflineReportReq(nullptr, std::move(from)) {}
  inline OfflineReportReq& operator=(const OfflineReportReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline OfflineReportReq& operator=(OfflineReportReq&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OfflineReportReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const OfflineReportReq* internal_default_instance() {
    return reinterpret_cast<const OfflineReportReq*>(
        &_OfflineReportReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(OfflineReportReq& a, OfflineReportReq& b) { a.Swap(&b); }
  inline void Swap(OfflineReportReq* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OfflineReportReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OfflineReportReq* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<OfflineReportReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OfflineReportReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const OfflineReportReq& from) { OfflineReportReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(OfflineReportReq* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.OfflineReportReq"; }

 protected:
  explicit OfflineReportReq(::google::protobuf::Arena* arena);
  OfflineReportReq(::google::protobuf::Arena* arena, const OfflineReportReq& from);
  OfflineReportReq(::google::protobuf::Arena* arena, OfflineReportReq&& from) noexcept
      : OfflineReportReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUidFieldNumber = 1,
  };
  // string uid = 1;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // @@protoc_insertion_point(class_scope:status.OfflineReportReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      35, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const OfflineReportReq& from_msg);
    ::google::protobuf::internal::ArenaStringPtr uid_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.NodeInfo) */ {
 public:
  inline NodeInfo() : NodeInfo(nullptr) {}
  ~NodeInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NodeInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NodeInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeInfo(const NodeInfo& from) : NodeInfo(nullptr, from) {}
  inline NodeInfo(NodeInfo&& from) noexcept
      : NodeInfo(nullptr, std::move(from)) {}
  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
        &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(NodeInfo& a, NodeInfo& b) { a.Swap(&b); }
  inline void Swap(NodeInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NodeInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeInfo& from) { NodeInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NodeInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.NodeInfo"; }

 protected:
  explicit NodeInfo(::google::protobuf::Arena* arena);
  NodeInfo(::google::protobuf::Arena* arena, const NodeInfo& from);
  NodeInfo(::google::protobuf::Arena* arena, NodeInfo&& from) noexcept
      : NodeInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kServerHostFieldNumber = 2,
    kServerPortFieldNumber = 3,
    kCurrentLoadFieldNumber = 4,
    kLastHeartbeatFieldNumber = 6,
    kCapacityFieldNumber = 5,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string server_host = 2;
  void clear_server_host() ;
  const std::string& server_host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_host(Arg_&& arg, Args_... args);
  std::string* mutable_server_host();
  PROTOBUF_NODISCARD std::string* release_server_host();
  void set_allocated_server_host(std::string* value);

  private:
  const std::string& _internal_server_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_host(
      const std::string& value);
  std::string* _internal_mutable_server_host();

  public:
  // int32 server_port = 3;
  void clear_server_port() ;
  ::int32_t server_port() const;
  void set_server_port(::int32_t value);

  private:
  ::int32_t _internal_server_port() const;
  void _internal_set_server_port(::int32_t value);

  public:
  // int32 current_load = 4;
  void clear_current_load() ;
  ::int32_t current_load() const;
  void set_current_load(::int32_t value);

  private:
  ::int32_t _internal_current_load() const;
  void _internal_set_current_load(::int32_t value);

  public:
  // int64 last_heartbeat = 6;
  void clear_last_heartbeat() ;
  ::int64_t last_heartbeat() const;
  void set_last_heartbeat(::int64_t value);

  private:
  ::int64_t _internal_last_heartbeat() const;
  void _internal_set_last_heartbeat(::int64_t value);

  public:
  // int32 capacity = 5;
  void clear_capacity() ;
  ::int32_t capacity() const;
  void set_capacity(::int32_t value);

  private:
  ::int32_t _internal_capacity() const;
  void _internal_set_capacity(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:status.NodeInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      39, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NodeInfo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr server_host_;
    ::int32_t server_port_;
    ::int32_t current_load_;
    ::int64_t last_heartbeat_;
    ::int32_t capacity_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class KickUserResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.KickUserResp) */ {
 public:
  inline KickUserResp() : KickUserResp(nullptr) {}
  ~KickUserResp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(KickUserResp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(KickUserResp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KickUserResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline KickUserResp(const KickUserResp& from) : KickUserResp(nullptr, from) {}
  inline KickUserResp(KickUserResp&& from) noexcept
      : KickUserResp(nullptr, std::move(from)) {}
  inline KickUserResp& operator=(const KickUserResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline KickUserResp& operator=(KickUserResp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KickUserResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const KickUserResp* internal_default_instance() {
    return reinterpret_cast<const KickUserResp*>(
        &_KickUserResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(KickUserResp& a, KickUserResp& b) { a.Swap(&b); }
  inline void Swap(KickUserResp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KickUserResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KickUserResp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<KickUserResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KickUserResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KickUserResp& from) { KickUserResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(KickUserResp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.KickUserResp"; }

 protected:
  explicit KickUserResp(::google::protobuf::Arena* arena);
  KickUserResp(::google::protobuf::Arena* arena, const KickUserResp& from);
  KickUserResp(::google::protobuf::Arena* arena, KickUserResp&& from) noexcept
      : KickUserResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 1,
  };
  // int32 error = 1;
  void clear_error() ;
  ::int32_t error() const;
  void set_error(::int32_t value);

  private:
  ::int32_t _internal_error() const;
  void _internal_set_error(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:status.KickUserResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KickUserResp& from_msg);
    ::int32_t error_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class KickUserReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.KickUserReq) */ {
 public:
  inline KickUserReq() : KickUserReq(nullptr) {}
  ~KickUserReq() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(KickUserReq* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(KickUserReq));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KickUserReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline KickUserReq(const KickUserReq& from) : KickUserReq(nullptr, from) {}
  inline KickUserReq(KickUserReq&& from) noexcept
      : KickUserReq(nullptr, std::move(from)) {}
  inline KickUserReq& operator=(const KickUserReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline KickUserReq& operator=(KickUserReq&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KickUserReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const KickUserReq* internal_default_instance() {
    return reinterpret_cast<const KickUserReq*>(
        &_KickUserReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(KickUserReq& a, KickUserReq& b) { a.Swap(&b); }
  inline void Swap(KickUserReq* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KickUserReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KickUserReq* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<KickUserReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KickUserReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KickUserReq& from) { KickUserReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(KickUserReq* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.KickUserReq"; }

 protected:
  explicit KickUserReq(::google::protobuf::Arena* arena);
  KickUserReq(::google::protobuf::Arena* arena, const KickUserReq& from);
  KickUserReq(::google::protobuf::Arena* arena, KickUserReq&& from) noexcept
      : KickUserReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUidFieldNumber = 1,
    kReasonFieldNumber = 2,
  };
  // string uid = 1;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // int32 reason = 2;
  void clear_reason() ;
  ::int32_t reason() const;
  void set_reason(::int32_t value);

  private:
  ::int32_t _internal_reason() const;
  void _internal_set_reason(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:status.KickUserReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      30, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KickUserReq& from_msg);
    ::google::protobuf::internal::ArenaStringPtr uid_;
    ::int32_t reason_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.HeartbeatResp) */ {
 public:
  inline HeartbeatResp() : HeartbeatResp(nullptr) {}
  ~HeartbeatResp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HeartbeatResp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HeartbeatResp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeartbeatResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeartbeatResp(const HeartbeatResp& from) : HeartbeatResp(nullptr, from) {}
  inline HeartbeatResp(HeartbeatResp&& from) noexcept
      : HeartbeatResp(nullptr, std::move(from)) {}
  inline HeartbeatResp& operator=(const HeartbeatResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatResp& operator=(HeartbeatResp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatResp* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResp*>(
        &_HeartbeatResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(HeartbeatResp& a, HeartbeatResp& b) { a.Swap(&b); }
  inline void Swap(HeartbeatResp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatResp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HeartbeatResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeartbeatResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeartbeatResp& from) { HeartbeatResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HeartbeatResp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.HeartbeatResp"; }

 protected:
  explicit HeartbeatResp(::google::protobuf::Arena* arena);
  HeartbeatResp(::google::protobuf::Arena* arena, const HeartbeatResp& from);
  HeartbeatResp(::google::protobuf::Arena* arena, HeartbeatResp&& from) noexcept
      : HeartbeatResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 1,
  };
  // int32 error = 1;
  void clear_error() ;
  ::int32_t error() const;
  void set_error(::int32_t value);

  private:
  ::int32_t _internal_error() const;
  void _internal_set_error(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:status.HeartbeatResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HeartbeatResp& from_msg);
    ::int32_t error_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.HeartbeatReq) */ {
 public:
  inline HeartbeatReq() : HeartbeatReq(nullptr) {}
  ~HeartbeatReq() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HeartbeatReq* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HeartbeatReq));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeartbeatReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeartbeatReq(const HeartbeatReq& from) : HeartbeatReq(nullptr, from) {}
  inline HeartbeatReq(HeartbeatReq&& from) noexcept
      : HeartbeatReq(nullptr, std::move(from)) {}
  inline HeartbeatReq& operator=(const HeartbeatReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatReq& operator=(HeartbeatReq&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatReq* internal_default_instance() {
    return reinterpret_cast<const HeartbeatReq*>(
        &_HeartbeatReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(HeartbeatReq& a, HeartbeatReq& b) { a.Swap(&b); }
  inline void Swap(HeartbeatReq* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatReq* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HeartbeatReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeartbeatReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeartbeatReq& from) { HeartbeatReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HeartbeatReq* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.HeartbeatReq"; }

 protected:
  explicit HeartbeatReq(::google::protobuf::Arena* arena);
  HeartbeatReq(::google::protobuf::Arena* arena, const HeartbeatReq& from);
  HeartbeatReq(::google::protobuf::Arena* arena, HeartbeatReq&& from) noexcept
      : HeartbeatReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kServerHostFieldNumber = 2,
    kServerPortFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string server_host = 2;
  void clear_server_host() ;
  const std::string& server_host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_host(Arg_&& arg, Args_... args);
  std::string* mutable_server_host();
  PROTOBUF_NODISCARD std::string* release_server_host();
  void set_allocated_server_host(std::string* value);

  private:
  const std::string& _internal_server_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_host(
      const std::string& value);
  std::string* _internal_mutable_server_host();

  public:
  // int32 server_port = 3;
  void clear_server_port() ;
  ::int32_t server_port() const;
  void set_server_port(::int32_t value);

  private:
  ::int32_t _internal_server_port() const;
  void _internal_set_server_port(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:status.HeartbeatReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      43, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HeartbeatReq& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr server_host_;
    ::int32_t server_port_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class GetNodesReq final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:status.GetNodesReq) */ {
 public:
  inline GetNodesReq() : GetNodesReq(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetNodesReq* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetNodesReq));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetNodesReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetNodesReq(const GetNodesReq& from) : GetNodesReq(nullptr, from) {}
  inline GetNodesReq(GetNodesReq&& from) noexcept
      : GetNodesReq(nullptr, std::move(from)) {}
  inline GetNodesReq& operator=(const GetNodesReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNodesReq& operator=(GetNodesReq&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNodesReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNodesReq* internal_default_instance() {
    return reinterpret_cast<const GetNodesReq*>(
        &_GetNodesReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(GetNodesReq& a, GetNodesReq& b) { a.Swap(&b); }
  inline void Swap(GetNodesReq* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNodesReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNodesReq* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<GetNodesReq>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetNodesReq& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetNodesReq& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.GetNodesReq"; }

 protected:
  explicit GetNodesReq(::google::protobuf::Arena* arena);
  GetNodesReq(::google::protobuf::Arena* arena, const GetNodesReq& from);
  GetNodesReq(::google::protobuf::Arena* arena, GetNodesReq&& from) noexcept
      : GetNodesReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:status.GetNodesReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetNodesReq& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class DeregisterNodeResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.DeregisterNodeResp) */ {
 public:
  inline DeregisterNodeResp() : DeregisterNodeResp(nullptr) {}
  ~DeregisterNodeResp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeregisterNodeResp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeregisterNodeResp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeregisterNodeResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeregisterNodeResp(const DeregisterNodeResp& from) : DeregisterNodeResp(nullptr, from) {}
  inline DeregisterNodeResp(DeregisterNodeResp&& from) noexcept
      : DeregisterNodeResp(nullptr, std::move(from)) {}
  inline DeregisterNodeResp& operator=(const DeregisterNodeResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeregisterNodeResp& operator=(DeregisterNodeResp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeregisterNodeResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeregisterNodeResp* internal_default_instance() {
    return reinterpret_cast<const DeregisterNodeResp*>(
        &_DeregisterNodeResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(DeregisterNodeResp& a, DeregisterNodeResp& b) { a.Swap(&b); }
  inline void Swap(DeregisterNodeResp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeregisterNodeResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeregisterNodeResp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeregisterNodeResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeregisterNodeResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeregisterNodeResp& from) { DeregisterNodeResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeregisterNodeResp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.DeregisterNodeResp"; }

 protected:
  explicit DeregisterNodeResp(::google::protobuf::Arena* arena);
  DeregisterNodeResp(::google::protobuf::Arena* arena, const DeregisterNodeResp& from);
  DeregisterNodeResp(::google::protobuf::Arena* arena, DeregisterNodeResp&& from) noexcept
      : DeregisterNodeResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrorFieldNumber = 1,
  };
  // int32 error = 1;
  void clear_error() ;
  ::int32_t error() const;
  void set_error(::int32_t value);

  private:
  ::int32_t _internal_error() const;
  void _internal_set_error(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:status.DeregisterNodeResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeregisterNodeResp& from_msg);
    ::int32_t error_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class DeregisterNodeReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.DeregisterNodeReq) */ {
 public:
  inline DeregisterNodeReq() : DeregisterNodeReq(nullptr) {}
  ~DeregisterNodeReq() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeregisterNodeReq* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeregisterNodeReq));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeregisterNodeReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeregisterNodeReq(const DeregisterNodeReq& from) : DeregisterNodeReq(nullptr, from) {}
  inline DeregisterNodeReq(DeregisterNodeReq&& from) noexcept
      : DeregisterNodeReq(nullptr, std::move(from)) {}
  inline DeregisterNodeReq& operator=(const DeregisterNodeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeregisterNodeReq& operator=(DeregisterNodeReq&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeregisterNodeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeregisterNodeReq* internal_default_instance() {
    return reinterpret_cast<const DeregisterNodeReq*>(
        &_DeregisterNodeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(DeregisterNodeReq& a, DeregisterNodeReq& b) { a.Swap(&b); }
  inline void Swap(DeregisterNodeReq* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeregisterNodeReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeregisterNodeReq* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeregisterNodeReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeregisterNodeReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeregisterNodeReq& from) { DeregisterNodeReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeregisterNodeReq* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.DeregisterNodeReq"; }

 protected:
  explicit DeregisterNodeReq(::google::protobuf::Arena* arena);
  DeregisterNodeReq(::google::protobuf::Arena* arena, const DeregisterNodeReq& from);
  DeregisterNodeReq(::google::protobuf::Arena* arena, DeregisterNodeReq&& from) noexcept
      : DeregisterNodeReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:status.DeregisterNodeReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      37, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeregisterNodeReq& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class AllocateServerResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.AllocateServerResp) */ {
 public:
  inline AllocateServerResp() : AllocateServerResp(nullptr) {}
  ~AllocateServerResp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AllocateServerResp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AllocateServerResp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AllocateServerResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline AllocateServerResp(const AllocateServerResp& from) : AllocateServerResp(nullptr, from) {}
  inline AllocateServerResp(AllocateServerResp&& from) noexcept
      : AllocateServerResp(nullptr, std::move(from)) {}
  inline AllocateServerResp& operator=(const AllocateServerResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocateServerResp& operator=(AllocateServerResp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllocateServerResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllocateServerResp* internal_default_instance() {
    return reinterpret_cast<const AllocateServerResp*>(
        &_AllocateServerResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(AllocateServerResp& a, AllocateServerResp& b) { a.Swap(&b); }
  inline void Swap(AllocateServerResp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocateServerResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllocateServerResp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AllocateServerResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AllocateServerResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AllocateServerResp& from) { AllocateServerResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AllocateServerResp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.AllocateServerResp"; }

 protected:
  explicit AllocateServerResp(::google::protobuf::Arena* arena);
  AllocateServerResp(::google::protobuf::Arena* arena, const AllocateServerResp& from);
  AllocateServerResp(::google::protobuf::Arena* arena, AllocateServerResp&& from) noexcept
      : AllocateServerResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kServerNameFieldNumber = 3,
    kServerHostFieldNumber = 4,
    kTokenFieldNumber = 6,
    kErrorFieldNumber = 1,
    kAssignedFieldNumber = 2,
    kExpiresAtFieldNumber = 7,
    kServerPortFieldNumber = 5,
  };
  // string server_name = 3;
  void clear_server_name() ;
  const std::string& server_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_name(Arg_&& arg, Args_... args);
  std::string* mutable_server_name();
  PROTOBUF_NODISCARD std::string* release_server_name();
  void set_allocated_server_name(std::string* value);

  private:
  const std::string& _internal_server_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_name(
      const std::string& value);
  std::string* _internal_mutable_server_name();

  public:
  // string server_host = 4;
  void clear_server_host() ;
  const std::string& server_host() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_host(Arg_&& arg, Args_... args);
  std::string* mutable_server_host();
  PROTOBUF_NODISCARD std::string* release_server_host();
  void set_allocated_server_host(std::string* value);

  private:
  const std::string& _internal_server_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_host(
      const std::string& value);
  std::string* _internal_mutable_server_host();

  public:
  // string token = 6;
  void clear_token() ;
  const std::string& token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* value);

  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(
      const std::string& value);
  std::string* _internal_mutable_token();

  public:
  // int32 error = 1;
  void clear_error() ;
  ::int32_t error() const;
  void set_error(::int32_t value);

  private:
  ::int32_t _internal_error() const;
  void _internal_set_error(::int32_t value);

  public:
  // bool assigned = 2;
  void clear_assigned() ;
  bool assigned() const;
  void set_assigned(bool value);

  private:
  bool _internal_assigned() const;
  void _internal_set_assigned(bool value);

  public:
  // int64 expires_at = 7;
  void clear_expires_at() ;
  ::int64_t expires_at() const;
  void set_expires_at(::int64_t value);

  private:
  ::int64_t _internal_expires_at() const;
  void _internal_set_expires_at(::int64_t value);

  public:
  // int32 server_port = 5;
  void clear_server_port() ;
  ::int32_t server_port() const;
  void set_server_port(::int32_t value);

  private:
  ::int32_t _internal_server_port() const;
  void _internal_set_server_port(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:status.AllocateServerResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      61, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AllocateServerResp& from_msg);
    ::google::protobuf::internal::ArenaStringPtr server_name_;
    ::google::protobuf::internal::ArenaStringPtr server_host_;
    ::google::protobuf::internal::ArenaStringPtr token_;
    ::int32_t error_;
    bool assigned_;
    ::int64_t expires_at_;
    ::int32_t server_port_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class AllocateServerReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.AllocateServerReq) */ {
 public:
  inline AllocateServerReq() : AllocateServerReq(nullptr) {}
  ~AllocateServerReq() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AllocateServerReq* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AllocateServerReq));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AllocateServerReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline AllocateServerReq(const AllocateServerReq& from) : AllocateServerReq(nullptr, from) {}
  inline AllocateServerReq(AllocateServerReq&& from) noexcept
      : AllocateServerReq(nullptr, std::move(from)) {}
  inline AllocateServerReq& operator=(const AllocateServerReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllocateServerReq& operator=(AllocateServerReq&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllocateServerReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllocateServerReq* internal_default_instance() {
    return reinterpret_cast<const AllocateServerReq*>(
        &_AllocateServerReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(AllocateServerReq& a, AllocateServerReq& b) { a.Swap(&b); }
  inline void Swap(AllocateServerReq* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllocateServerReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllocateServerReq* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AllocateServerReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AllocateServerReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AllocateServerReq& from) { AllocateServerReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AllocateServerReq* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.AllocateServerReq"; }

 protected:
  explicit AllocateServerReq(::google::protobuf::Arena* arena);
  AllocateServerReq(::google::protobuf::Arena* arena, const AllocateServerReq& from);
  AllocateServerReq(::google::protobuf::Arena* arena, AllocateServerReq&& from) noexcept
      : AllocateServerReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUidFieldNumber = 1,
  };
  // string uid = 1;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // @@protoc_insertion_point(class_scope:status.AllocateServerReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      36, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AllocateServerReq& from_msg);
    ::google::protobuf::internal::ArenaStringPtr uid_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class GetNodesResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:status.GetNodesResp) */ {
 public:
  inline GetNodesResp() : GetNodesResp(nullptr) {}
  ~GetNodesResp() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetNodesResp* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetNodesResp));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetNodesResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetNodesResp(const GetNodesResp& from) : GetNodesResp(nullptr, from) {}
  inline GetNodesResp(GetNodesResp&& from) noexcept
      : GetNodesResp(nullptr, std::move(from)) {}
  inline GetNodesResp& operator=(const GetNodesResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNodesResp& operator=(GetNodesResp&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNodesResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNodesResp* internal_default_instance() {
    return reinterpret_cast<const GetNodesResp*>(
        &_GetNodesResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(GetNodesResp& a, GetNodesResp& b) { a.Swap(&b); }
  inline void Swap(GetNodesResp* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNodesResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNodesResp* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetNodesResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetNodesResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetNodesResp& from) { GetNodesResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetNodesResp* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "status.GetNodesResp"; }

 protected:
  explicit GetNodesResp(::google::protobuf::Arena* arena);
  GetNodesResp(::google::protobuf::Arena* arena, const GetNodesResp& from);
  GetNodesResp(::google::protobuf::Arena* arena, GetNodesResp&& from) noexcept
      : GetNodesResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodesFieldNumber = 2,
    kErrorFieldNumber = 1,
  };
  // repeated .status.NodeInfo nodes = 2;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;

  public:
  void clear_nodes() ;
  ::status::NodeInfo* mutable_nodes(int index);
  ::google::protobuf::RepeatedPtrField<::status::NodeInfo>* mutable_nodes();

  private:
  const ::google::protobuf::RepeatedPtrField<::status::NodeInfo>& _internal_nodes() const;
  ::google::protobuf::RepeatedPtrField<::status::NodeInfo>* _internal_mutable_nodes();
  public:
  const ::status::NodeInfo& nodes(int index) const;
  ::status::NodeInfo* add_nodes();
  const ::google::protobuf::RepeatedPtrField<::status::NodeInfo>& nodes() const;
  // int32 error = 1;
  void clear_error() ;
  ::int32_t error() const;
  void set_error(::int32_t value);

  private:
  ::int32_t _internal_error() const;
  void _internal_set_error(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:status.GetNodesResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetNodesResp& from_msg);
    ::google::protobuf::RepeatedPtrField< ::status::NodeInfo > nodes_;
    ::int32_t error_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_status_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// RegisterNodeReq

// string name = 1;
inline void RegisterNodeReq::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RegisterNodeReq::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.RegisterNodeReq.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterNodeReq::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.RegisterNodeReq.name)
}
inline std::string* RegisterNodeReq::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:status.RegisterNodeReq.name)
  return _s;
}
inline const std::string& RegisterNodeReq::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void RegisterNodeReq::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* RegisterNodeReq::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* RegisterNodeReq::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.RegisterNodeReq.name)
  return _impl_.name_.Release();
}
inline void RegisterNodeReq::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.RegisterNodeReq.name)
}

// string server_host = 2;
inline void RegisterNodeReq::clear_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.ClearToEmpty();
}
inline const std::string& RegisterNodeReq::server_host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.RegisterNodeReq.server_host)
  return _internal_server_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RegisterNodeReq::set_server_host(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.RegisterNodeReq.server_host)
}
inline std::string* RegisterNodeReq::mutable_server_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_server_host();
  // @@protoc_insertion_point(field_mutable:status.RegisterNodeReq.server_host)
  return _s;
}
inline const std::string& RegisterNodeReq::_internal_server_host() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_host_.Get();
}
inline void RegisterNodeReq::_internal_set_server_host(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.Set(value, GetArena());
}
inline std::string* RegisterNodeReq::_internal_mutable_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.server_host_.Mutable( GetArena());
}
inline std::string* RegisterNodeReq::release_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.RegisterNodeReq.server_host)
  return _impl_.server_host_.Release();
}
inline void RegisterNodeReq::set_allocated_server_host(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.server_host_.IsDefault()) {
    _impl_.server_host_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.RegisterNodeReq.server_host)
}

// int32 server_port = 3;
inline void RegisterNodeReq::clear_server_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_port_ = 0;
}
inline ::int32_t RegisterNodeReq::server_port() const {
  // @@protoc_insertion_point(field_get:status.RegisterNodeReq.server_port)
  return _internal_server_port();
}
inline void RegisterNodeReq::set_server_port(::int32_t value) {
  _internal_set_server_port(value);
  // @@protoc_insertion_point(field_set:status.RegisterNodeReq.server_port)
}
inline ::int32_t RegisterNodeReq::_internal_server_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_port_;
}
inline void RegisterNodeReq::_internal_set_server_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_port_ = value;
}

// int32 capacity = 4;
inline void RegisterNodeReq::clear_capacity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capacity_ = 0;
}
inline ::int32_t RegisterNodeReq::capacity() const {
  // @@protoc_insertion_point(field_get:status.RegisterNodeReq.capacity)
  return _internal_capacity();
}
inline void RegisterNodeReq::set_capacity(::int32_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:status.RegisterNodeReq.capacity)
}
inline ::int32_t RegisterNodeReq::_internal_capacity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.capacity_;
}
inline void RegisterNodeReq::_internal_set_capacity(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capacity_ = value;
}

// -------------------------------------------------------------------

// RegisterNodeResp

// int32 error = 1;
inline void RegisterNodeResp::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = 0;
}
inline ::int32_t RegisterNodeResp::error() const {
  // @@protoc_insertion_point(field_get:status.RegisterNodeResp.error)
  return _internal_error();
}
inline void RegisterNodeResp::set_error(::int32_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:status.RegisterNodeResp.error)
}
inline ::int32_t RegisterNodeResp::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_;
}
inline void RegisterNodeResp::_internal_set_error(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = value;
}

// -------------------------------------------------------------------

// DeregisterNodeReq

// string name = 1;
inline void DeregisterNodeReq::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DeregisterNodeReq::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.DeregisterNodeReq.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeregisterNodeReq::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.DeregisterNodeReq.name)
}
inline std::string* DeregisterNodeReq::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:status.DeregisterNodeReq.name)
  return _s;
}
inline const std::string& DeregisterNodeReq::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void DeregisterNodeReq::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* DeregisterNodeReq::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* DeregisterNodeReq::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.DeregisterNodeReq.name)
  return _impl_.name_.Release();
}
inline void DeregisterNodeReq::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.DeregisterNodeReq.name)
}

// -------------------------------------------------------------------

// DeregisterNodeResp

// int32 error = 1;
inline void DeregisterNodeResp::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = 0;
}
inline ::int32_t DeregisterNodeResp::error() const {
  // @@protoc_insertion_point(field_get:status.DeregisterNodeResp.error)
  return _internal_error();
}
inline void DeregisterNodeResp::set_error(::int32_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:status.DeregisterNodeResp.error)
}
inline ::int32_t DeregisterNodeResp::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_;
}
inline void DeregisterNodeResp::_internal_set_error(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = value;
}

// -------------------------------------------------------------------

// HeartbeatReq

// string name = 1;
inline void HeartbeatReq::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& HeartbeatReq::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.HeartbeatReq.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HeartbeatReq::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.HeartbeatReq.name)
}
inline std::string* HeartbeatReq::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:status.HeartbeatReq.name)
  return _s;
}
inline const std::string& HeartbeatReq::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void HeartbeatReq::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* HeartbeatReq::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* HeartbeatReq::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.HeartbeatReq.name)
  return _impl_.name_.Release();
}
inline void HeartbeatReq::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.HeartbeatReq.name)
}

// string server_host = 2;
inline void HeartbeatReq::clear_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.ClearToEmpty();
}
inline const std::string& HeartbeatReq::server_host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.HeartbeatReq.server_host)
  return _internal_server_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HeartbeatReq::set_server_host(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.HeartbeatReq.server_host)
}
inline std::string* HeartbeatReq::mutable_server_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_server_host();
  // @@protoc_insertion_point(field_mutable:status.HeartbeatReq.server_host)
  return _s;
}
inline const std::string& HeartbeatReq::_internal_server_host() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_host_.Get();
}
inline void HeartbeatReq::_internal_set_server_host(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.Set(value, GetArena());
}
inline std::string* HeartbeatReq::_internal_mutable_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.server_host_.Mutable( GetArena());
}
inline std::string* HeartbeatReq::release_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.HeartbeatReq.server_host)
  return _impl_.server_host_.Release();
}
inline void HeartbeatReq::set_allocated_server_host(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.server_host_.IsDefault()) {
    _impl_.server_host_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.HeartbeatReq.server_host)
}

// int32 server_port = 3;
inline void HeartbeatReq::clear_server_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_port_ = 0;
}
inline ::int32_t HeartbeatReq::server_port() const {
  // @@protoc_insertion_point(field_get:status.HeartbeatReq.server_port)
  return _internal_server_port();
}
inline void HeartbeatReq::set_server_port(::int32_t value) {
  _internal_set_server_port(value);
  // @@protoc_insertion_point(field_set:status.HeartbeatReq.server_port)
}
inline ::int32_t HeartbeatReq::_internal_server_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_port_;
}
inline void HeartbeatReq::_internal_set_server_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_port_ = value;
}

// -------------------------------------------------------------------

// HeartbeatResp

// int32 error = 1;
inline void HeartbeatResp::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = 0;
}
inline ::int32_t HeartbeatResp::error() const {
  // @@protoc_insertion_point(field_get:status.HeartbeatResp.error)
  return _internal_error();
}
inline void HeartbeatResp::set_error(::int32_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:status.HeartbeatResp.error)
}
inline ::int32_t HeartbeatResp::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_;
}
inline void HeartbeatResp::_internal_set_error(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = value;
}

// -------------------------------------------------------------------

// AllocateServerReq

// string uid = 1;
inline void AllocateServerReq::clear_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& AllocateServerReq::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.AllocateServerReq.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AllocateServerReq::set_uid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.AllocateServerReq.uid)
}
inline std::string* AllocateServerReq::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:status.AllocateServerReq.uid)
  return _s;
}
inline const std::string& AllocateServerReq::_internal_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uid_.Get();
}
inline void AllocateServerReq::_internal_set_uid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* AllocateServerReq::_internal_mutable_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* AllocateServerReq::release_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.AllocateServerReq.uid)
  return _impl_.uid_.Release();
}
inline void AllocateServerReq::set_allocated_uid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.AllocateServerReq.uid)
}

// -------------------------------------------------------------------

// AllocateServerResp

// int32 error = 1;
inline void AllocateServerResp::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = 0;
}
inline ::int32_t AllocateServerResp::error() const {
  // @@protoc_insertion_point(field_get:status.AllocateServerResp.error)
  return _internal_error();
}
inline void AllocateServerResp::set_error(::int32_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:status.AllocateServerResp.error)
}
inline ::int32_t AllocateServerResp::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_;
}
inline void AllocateServerResp::_internal_set_error(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = value;
}

// bool assigned = 2;
inline void AllocateServerResp::clear_assigned() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_ = false;
}
inline bool AllocateServerResp::assigned() const {
  // @@protoc_insertion_point(field_get:status.AllocateServerResp.assigned)
  return _internal_assigned();
}
inline void AllocateServerResp::set_assigned(bool value) {
  _internal_set_assigned(value);
  // @@protoc_insertion_point(field_set:status.AllocateServerResp.assigned)
}
inline bool AllocateServerResp::_internal_assigned() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.assigned_;
}
inline void AllocateServerResp::_internal_set_assigned(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.assigned_ = value;
}

// string server_name = 3;
inline void AllocateServerResp::clear_server_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_name_.ClearToEmpty();
}
inline const std::string& AllocateServerResp::server_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.AllocateServerResp.server_name)
  return _internal_server_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AllocateServerResp::set_server_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.AllocateServerResp.server_name)
}
inline std::string* AllocateServerResp::mutable_server_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_server_name();
  // @@protoc_insertion_point(field_mutable:status.AllocateServerResp.server_name)
  return _s;
}
inline const std::string& AllocateServerResp::_internal_server_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_name_.Get();
}
inline void AllocateServerResp::_internal_set_server_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_name_.Set(value, GetArena());
}
inline std::string* AllocateServerResp::_internal_mutable_server_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.server_name_.Mutable( GetArena());
}
inline std::string* AllocateServerResp::release_server_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.AllocateServerResp.server_name)
  return _impl_.server_name_.Release();
}
inline void AllocateServerResp::set_allocated_server_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.server_name_.IsDefault()) {
    _impl_.server_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.AllocateServerResp.server_name)
}

// string server_host = 4;
inline void AllocateServerResp::clear_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.ClearToEmpty();
}
inline const std::string& AllocateServerResp::server_host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.AllocateServerResp.server_host)
  return _internal_server_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AllocateServerResp::set_server_host(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.AllocateServerResp.server_host)
}
inline std::string* AllocateServerResp::mutable_server_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_server_host();
  // @@protoc_insertion_point(field_mutable:status.AllocateServerResp.server_host)
  return _s;
}
inline const std::string& AllocateServerResp::_internal_server_host() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_host_.Get();
}
inline void AllocateServerResp::_internal_set_server_host(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.Set(value, GetArena());
}
inline std::string* AllocateServerResp::_internal_mutable_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.server_host_.Mutable( GetArena());
}
inline std::string* AllocateServerResp::release_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.AllocateServerResp.server_host)
  return _impl_.server_host_.Release();
}
inline void AllocateServerResp::set_allocated_server_host(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.server_host_.IsDefault()) {
    _impl_.server_host_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.AllocateServerResp.server_host)
}

// int32 server_port = 5;
inline void AllocateServerResp::clear_server_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_port_ = 0;
}
inline ::int32_t AllocateServerResp::server_port() const {
  // @@protoc_insertion_point(field_get:status.AllocateServerResp.server_port)
  return _internal_server_port();
}
inline void AllocateServerResp::set_server_port(::int32_t value) {
  _internal_set_server_port(value);
  // @@protoc_insertion_point(field_set:status.AllocateServerResp.server_port)
}
inline ::int32_t AllocateServerResp::_internal_server_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_port_;
}
inline void AllocateServerResp::_internal_set_server_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_port_ = value;
}

// string token = 6;
inline void AllocateServerResp::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& AllocateServerResp::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.AllocateServerResp.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AllocateServerResp::set_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.AllocateServerResp.token)
}
inline std::string* AllocateServerResp::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:status.AllocateServerResp.token)
  return _s;
}
inline const std::string& AllocateServerResp::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void AllocateServerResp::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(value, GetArena());
}
inline std::string* AllocateServerResp::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* AllocateServerResp::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.AllocateServerResp.token)
  return _impl_.token_.Release();
}
inline void AllocateServerResp::set_allocated_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.AllocateServerResp.token)
}

// int64 expires_at = 7;
inline void AllocateServerResp::clear_expires_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_at_ = ::int64_t{0};
}
inline ::int64_t AllocateServerResp::expires_at() const {
  // @@protoc_insertion_point(field_get:status.AllocateServerResp.expires_at)
  return _internal_expires_at();
}
inline void AllocateServerResp::set_expires_at(::int64_t value) {
  _internal_set_expires_at(value);
  // @@protoc_insertion_point(field_set:status.AllocateServerResp.expires_at)
}
inline ::int64_t AllocateServerResp::_internal_expires_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.expires_at_;
}
inline void AllocateServerResp::_internal_set_expires_at(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.expires_at_ = value;
}

// -------------------------------------------------------------------

// OnlineReportReq

// string uid = 1;
inline void OnlineReportReq::clear_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& OnlineReportReq::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.OnlineReportReq.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OnlineReportReq::set_uid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.OnlineReportReq.uid)
}
inline std::string* OnlineReportReq::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:status.OnlineReportReq.uid)
  return _s;
}
inline const std::string& OnlineReportReq::_internal_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uid_.Get();
}
inline void OnlineReportReq::_internal_set_uid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* OnlineReportReq::_internal_mutable_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* OnlineReportReq::release_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.OnlineReportReq.uid)
  return _impl_.uid_.Release();
}
inline void OnlineReportReq::set_allocated_uid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.OnlineReportReq.uid)
}

// string server_name = 2;
inline void OnlineReportReq::clear_server_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_name_.ClearToEmpty();
}
inline const std::string& OnlineReportReq::server_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.OnlineReportReq.server_name)
  return _internal_server_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OnlineReportReq::set_server_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.OnlineReportReq.server_name)
}
inline std::string* OnlineReportReq::mutable_server_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_server_name();
  // @@protoc_insertion_point(field_mutable:status.OnlineReportReq.server_name)
  return _s;
}
inline const std::string& OnlineReportReq::_internal_server_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_name_.Get();
}
inline void OnlineReportReq::_internal_set_server_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_name_.Set(value, GetArena());
}
inline std::string* OnlineReportReq::_internal_mutable_server_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.server_name_.Mutable( GetArena());
}
inline std::string* OnlineReportReq::release_server_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.OnlineReportReq.server_name)
  return _impl_.server_name_.Release();
}
inline void OnlineReportReq::set_allocated_server_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.server_name_.IsDefault()) {
    _impl_.server_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.OnlineReportReq.server_name)
}

// string server_host = 3;
inline void OnlineReportReq::clear_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.ClearToEmpty();
}
inline const std::string& OnlineReportReq::server_host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.OnlineReportReq.server_host)
  return _internal_server_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OnlineReportReq::set_server_host(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.OnlineReportReq.server_host)
}
inline std::string* OnlineReportReq::mutable_server_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_server_host();
  // @@protoc_insertion_point(field_mutable:status.OnlineReportReq.server_host)
  return _s;
}
inline const std::string& OnlineReportReq::_internal_server_host() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_host_.Get();
}
inline void OnlineReportReq::_internal_set_server_host(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.Set(value, GetArena());
}
inline std::string* OnlineReportReq::_internal_mutable_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.server_host_.Mutable( GetArena());
}
inline std::string* OnlineReportReq::release_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.OnlineReportReq.server_host)
  return _impl_.server_host_.Release();
}
inline void OnlineReportReq::set_allocated_server_host(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.server_host_.IsDefault()) {
    _impl_.server_host_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.OnlineReportReq.server_host)
}

// int32 server_port = 4;
inline void OnlineReportReq::clear_server_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_port_ = 0;
}
inline ::int32_t OnlineReportReq::server_port() const {
  // @@protoc_insertion_point(field_get:status.OnlineReportReq.server_port)
  return _internal_server_port();
}
inline void OnlineReportReq::set_server_port(::int32_t value) {
  _internal_set_server_port(value);
  // @@protoc_insertion_point(field_set:status.OnlineReportReq.server_port)
}
inline ::int32_t OnlineReportReq::_internal_server_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_port_;
}
inline void OnlineReportReq::_internal_set_server_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_port_ = value;
}

// string token = 5;
inline void OnlineReportReq::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& OnlineReportReq::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.OnlineReportReq.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OnlineReportReq::set_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.OnlineReportReq.token)
}
inline std::string* OnlineReportReq::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:status.OnlineReportReq.token)
  return _s;
}
inline const std::string& OnlineReportReq::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void OnlineReportReq::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(value, GetArena());
}
inline std::string* OnlineReportReq::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* OnlineReportReq::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.OnlineReportReq.token)
  return _impl_.token_.Release();
}
inline void OnlineReportReq::set_allocated_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.OnlineReportReq.token)
}

// -------------------------------------------------------------------

// OnlineReportResp

// int32 error = 1;
inline void OnlineReportResp::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = 0;
}
inline ::int32_t OnlineReportResp::error() const {
  // @@protoc_insertion_point(field_get:status.OnlineReportResp.error)
  return _internal_error();
}
inline void OnlineReportResp::set_error(::int32_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:status.OnlineReportResp.error)
}
inline ::int32_t OnlineReportResp::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_;
}
inline void OnlineReportResp::_internal_set_error(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = value;
}

// -------------------------------------------------------------------

// OfflineReportReq

// string uid = 1;
inline void OfflineReportReq::clear_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& OfflineReportReq::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.OfflineReportReq.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OfflineReportReq::set_uid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.OfflineReportReq.uid)
}
inline std::string* OfflineReportReq::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:status.OfflineReportReq.uid)
  return _s;
}
inline const std::string& OfflineReportReq::_internal_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uid_.Get();
}
inline void OfflineReportReq::_internal_set_uid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* OfflineReportReq::_internal_mutable_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* OfflineReportReq::release_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.OfflineReportReq.uid)
  return _impl_.uid_.Release();
}
inline void OfflineReportReq::set_allocated_uid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.OfflineReportReq.uid)
}

// -------------------------------------------------------------------

// OfflineReportResp

// int32 error = 1;
inline void OfflineReportResp::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = 0;
}
inline ::int32_t OfflineReportResp::error() const {
  // @@protoc_insertion_point(field_get:status.OfflineReportResp.error)
  return _internal_error();
}
inline void OfflineReportResp::set_error(::int32_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:status.OfflineReportResp.error)
}
inline ::int32_t OfflineReportResp::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_;
}
inline void OfflineReportResp::_internal_set_error(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = value;
}

// -------------------------------------------------------------------

// RouteReq

// string uid = 1;
inline void RouteReq::clear_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& RouteReq::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.RouteReq.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouteReq::set_uid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.RouteReq.uid)
}
inline std::string* RouteReq::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:status.RouteReq.uid)
  return _s;
}
inline const std::string& RouteReq::_internal_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uid_.Get();
}
inline void RouteReq::_internal_set_uid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* RouteReq::_internal_mutable_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* RouteReq::release_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.RouteReq.uid)
  return _impl_.uid_.Release();
}
inline void RouteReq::set_allocated_uid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.RouteReq.uid)
}

// -------------------------------------------------------------------

// RouteResp

// int32 error = 1;
inline void RouteResp::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = 0;
}
inline ::int32_t RouteResp::error() const {
  // @@protoc_insertion_point(field_get:status.RouteResp.error)
  return _internal_error();
}
inline void RouteResp::set_error(::int32_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:status.RouteResp.error)
}
inline ::int32_t RouteResp::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_;
}
inline void RouteResp::_internal_set_error(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = value;
}

// bool online = 2;
inline void RouteResp::clear_online() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.online_ = false;
}
inline bool RouteResp::online() const {
  // @@protoc_insertion_point(field_get:status.RouteResp.online)
  return _internal_online();
}
inline void RouteResp::set_online(bool value) {
  _internal_set_online(value);
  // @@protoc_insertion_point(field_set:status.RouteResp.online)
}
inline bool RouteResp::_internal_online() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.online_;
}
inline void RouteResp::_internal_set_online(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.online_ = value;
}

// string server_name = 3;
inline void RouteResp::clear_server_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_name_.ClearToEmpty();
}
inline const std::string& RouteResp::server_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.RouteResp.server_name)
  return _internal_server_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouteResp::set_server_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.RouteResp.server_name)
}
inline std::string* RouteResp::mutable_server_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_server_name();
  // @@protoc_insertion_point(field_mutable:status.RouteResp.server_name)
  return _s;
}
inline const std::string& RouteResp::_internal_server_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_name_.Get();
}
inline void RouteResp::_internal_set_server_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_name_.Set(value, GetArena());
}
inline std::string* RouteResp::_internal_mutable_server_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.server_name_.Mutable( GetArena());
}
inline std::string* RouteResp::release_server_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.RouteResp.server_name)
  return _impl_.server_name_.Release();
}
inline void RouteResp::set_allocated_server_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.server_name_.IsDefault()) {
    _impl_.server_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.RouteResp.server_name)
}

// string server_host = 4;
inline void RouteResp::clear_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.ClearToEmpty();
}
inline const std::string& RouteResp::server_host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.RouteResp.server_host)
  return _internal_server_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouteResp::set_server_host(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.RouteResp.server_host)
}
inline std::string* RouteResp::mutable_server_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_server_host();
  // @@protoc_insertion_point(field_mutable:status.RouteResp.server_host)
  return _s;
}
inline const std::string& RouteResp::_internal_server_host() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_host_.Get();
}
inline void RouteResp::_internal_set_server_host(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.Set(value, GetArena());
}
inline std::string* RouteResp::_internal_mutable_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.server_host_.Mutable( GetArena());
}
inline std::string* RouteResp::release_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.RouteResp.server_host)
  return _impl_.server_host_.Release();
}
inline void RouteResp::set_allocated_server_host(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.server_host_.IsDefault()) {
    _impl_.server_host_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.RouteResp.server_host)
}

// int32 server_port = 5;
inline void RouteResp::clear_server_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_port_ = 0;
}
inline ::int32_t RouteResp::server_port() const {
  // @@protoc_insertion_point(field_get:status.RouteResp.server_port)
  return _internal_server_port();
}
inline void RouteResp::set_server_port(::int32_t value) {
  _internal_set_server_port(value);
  // @@protoc_insertion_point(field_set:status.RouteResp.server_port)
}
inline ::int32_t RouteResp::_internal_server_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_port_;
}
inline void RouteResp::_internal_set_server_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_port_ = value;
}

// string token = 6;
inline void RouteResp::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
}
inline const std::string& RouteResp::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.RouteResp.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RouteResp::set_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.RouteResp.token)
}
inline std::string* RouteResp::mutable_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:status.RouteResp.token)
  return _s;
}
inline const std::string& RouteResp::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void RouteResp::_internal_set_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.Set(value, GetArena());
}
inline std::string* RouteResp::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.token_.Mutable( GetArena());
}
inline std::string* RouteResp::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.RouteResp.token)
  return _impl_.token_.Release();
}
inline void RouteResp::set_allocated_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.RouteResp.token)
}

// int64 last_logout = 7;
inline void RouteResp::clear_last_logout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_logout_ = ::int64_t{0};
}
inline ::int64_t RouteResp::last_logout() const {
  // @@protoc_insertion_point(field_get:status.RouteResp.last_logout)
  return _internal_last_logout();
}
inline void RouteResp::set_last_logout(::int64_t value) {
  _internal_set_last_logout(value);
  // @@protoc_insertion_point(field_set:status.RouteResp.last_logout)
}
inline ::int64_t RouteResp::_internal_last_logout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_logout_;
}
inline void RouteResp::_internal_set_last_logout(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_logout_ = value;
}

// -------------------------------------------------------------------

// KickUserReq

// string uid = 1;
inline void KickUserReq::clear_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& KickUserReq::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.KickUserReq.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KickUserReq::set_uid(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.KickUserReq.uid)
}
inline std::string* KickUserReq::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:status.KickUserReq.uid)
  return _s;
}
inline const std::string& KickUserReq::_internal_uid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.uid_.Get();
}
inline void KickUserReq::_internal_set_uid(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* KickUserReq::_internal_mutable_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* KickUserReq::release_uid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.KickUserReq.uid)
  return _impl_.uid_.Release();
}
inline void KickUserReq::set_allocated_uid(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.uid_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.KickUserReq.uid)
}

// int32 reason = 2;
inline void KickUserReq::clear_reason() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_ = 0;
}
inline ::int32_t KickUserReq::reason() const {
  // @@protoc_insertion_point(field_get:status.KickUserReq.reason)
  return _internal_reason();
}
inline void KickUserReq::set_reason(::int32_t value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:status.KickUserReq.reason)
}
inline ::int32_t KickUserReq::_internal_reason() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.reason_;
}
inline void KickUserReq::_internal_set_reason(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.reason_ = value;
}

// -------------------------------------------------------------------

// KickUserResp

// int32 error = 1;
inline void KickUserResp::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = 0;
}
inline ::int32_t KickUserResp::error() const {
  // @@protoc_insertion_point(field_get:status.KickUserResp.error)
  return _internal_error();
}
inline void KickUserResp::set_error(::int32_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:status.KickUserResp.error)
}
inline ::int32_t KickUserResp::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_;
}
inline void KickUserResp::_internal_set_error(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = value;
}

// -------------------------------------------------------------------

// GetNodesReq

// -------------------------------------------------------------------

// NodeInfo

// string name = 1;
inline void NodeInfo::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NodeInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.NodeInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeInfo::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.NodeInfo.name)
}
inline std::string* NodeInfo::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:status.NodeInfo.name)
  return _s;
}
inline const std::string& NodeInfo::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void NodeInfo::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* NodeInfo::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* NodeInfo::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.NodeInfo.name)
  return _impl_.name_.Release();
}
inline void NodeInfo::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.NodeInfo.name)
}

// string server_host = 2;
inline void NodeInfo::clear_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.ClearToEmpty();
}
inline const std::string& NodeInfo::server_host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.NodeInfo.server_host)
  return _internal_server_host();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeInfo::set_server_host(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:status.NodeInfo.server_host)
}
inline std::string* NodeInfo::mutable_server_host() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_server_host();
  // @@protoc_insertion_point(field_mutable:status.NodeInfo.server_host)
  return _s;
}
inline const std::string& NodeInfo::_internal_server_host() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_host_.Get();
}
inline void NodeInfo::_internal_set_server_host(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.Set(value, GetArena());
}
inline std::string* NodeInfo::_internal_mutable_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.server_host_.Mutable( GetArena());
}
inline std::string* NodeInfo::release_server_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:status.NodeInfo.server_host)
  return _impl_.server_host_.Release();
}
inline void NodeInfo::set_allocated_server_host(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_host_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.server_host_.IsDefault()) {
    _impl_.server_host_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:status.NodeInfo.server_host)
}

// int32 server_port = 3;
inline void NodeInfo::clear_server_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_port_ = 0;
}
inline ::int32_t NodeInfo::server_port() const {
  // @@protoc_insertion_point(field_get:status.NodeInfo.server_port)
  return _internal_server_port();
}
inline void NodeInfo::set_server_port(::int32_t value) {
  _internal_set_server_port(value);
  // @@protoc_insertion_point(field_set:status.NodeInfo.server_port)
}
inline ::int32_t NodeInfo::_internal_server_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.server_port_;
}
inline void NodeInfo::_internal_set_server_port(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.server_port_ = value;
}

// int32 current_load = 4;
inline void NodeInfo::clear_current_load() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_load_ = 0;
}
inline ::int32_t NodeInfo::current_load() const {
  // @@protoc_insertion_point(field_get:status.NodeInfo.current_load)
  return _internal_current_load();
}
inline void NodeInfo::set_current_load(::int32_t value) {
  _internal_set_current_load(value);
  // @@protoc_insertion_point(field_set:status.NodeInfo.current_load)
}
inline ::int32_t NodeInfo::_internal_current_load() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_load_;
}
inline void NodeInfo::_internal_set_current_load(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_load_ = value;
}

// int32 capacity = 5;
inline void NodeInfo::clear_capacity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capacity_ = 0;
}
inline ::int32_t NodeInfo::capacity() const {
  // @@protoc_insertion_point(field_get:status.NodeInfo.capacity)
  return _internal_capacity();
}
inline void NodeInfo::set_capacity(::int32_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:status.NodeInfo.capacity)
}
inline ::int32_t NodeInfo::_internal_capacity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.capacity_;
}
inline void NodeInfo::_internal_set_capacity(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capacity_ = value;
}

// int64 last_heartbeat = 6;
inline void NodeInfo::clear_last_heartbeat() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_heartbeat_ = ::int64_t{0};
}
inline ::int64_t NodeInfo::last_heartbeat() const {
  // @@protoc_insertion_point(field_get:status.NodeInfo.last_heartbeat)
  return _internal_last_heartbeat();
}
inline void NodeInfo::set_last_heartbeat(::int64_t value) {
  _internal_set_last_heartbeat(value);
  // @@protoc_insertion_point(field_set:status.NodeInfo.last_heartbeat)
}
inline ::int64_t NodeInfo::_internal_last_heartbeat() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_heartbeat_;
}
inline void NodeInfo::_internal_set_last_heartbeat(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_heartbeat_ = value;
}

// -------------------------------------------------------------------

// GetNodesResp

// int32 error = 1;
inline void GetNodesResp::clear_error() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = 0;
}
inline ::int32_t GetNodesResp::error() const {
  // @@protoc_insertion_point(field_get:status.GetNodesResp.error)
  return _internal_error();
}
inline void GetNodesResp::set_error(::int32_t value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:status.GetNodesResp.error)
}
inline ::int32_t GetNodesResp::_internal_error() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.error_;
}
inline void GetNodesResp::_internal_set_error(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.error_ = value;
}

// repeated .status.NodeInfo nodes = 2;
inline int GetNodesResp::_internal_nodes_size() const {
  return _internal_nodes().size();
}
inline int GetNodesResp::nodes_size() const {
  return _internal_nodes_size();
}
inline void GetNodesResp::clear_nodes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nodes_.Clear();
}
inline ::status::NodeInfo* GetNodesResp::mutable_nodes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:status.GetNodesResp.nodes)
  return _internal_mutable_nodes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::status::NodeInfo>* GetNodesResp::mutable_nodes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:status.GetNodesResp.nodes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_nodes();
}
inline const ::status::NodeInfo& GetNodesResp::nodes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:status.GetNodesResp.nodes)
  return _internal_nodes().Get(index);
}
inline ::status::NodeInfo* GetNodesResp::add_nodes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::status::NodeInfo* _add = _internal_mutable_nodes()->Add();
  // @@protoc_insertion_point(field_add:status.GetNodesResp.nodes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::status::NodeInfo>& GetNodesResp::nodes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:status.GetNodesResp.nodes)
  return _internal_nodes();
}
inline const ::google::protobuf::RepeatedPtrField<::status::NodeInfo>&
GetNodesResp::_internal_nodes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nodes_;
}
inline ::google::protobuf::RepeatedPtrField<::status::NodeInfo>*
GetNodesResp::_internal_mutable_nodes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.nodes_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace status


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // status_2eproto_2epb_2eh
